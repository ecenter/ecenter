<?php
// $Id$

/**
 * @file
 * E-Center network query interface.
 */

// Load vector class
require_once(dirname(__FILE__) . '/Vector2d.class.php');

// Load traceroute diff (to keep licensing issues clear)
require_once(dirname(__FILE__) . '/ecenter_weathermap_traceroute_diff.inc');

/**
 * Implementation of hook_menu().
 */
function ecenter_weathermap_menu() {
  $items['weathermap'] = array(
    'title' => 'E-Center Weather Map',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ecenter_weathermap_select_form'),
    'access arguments' => array('access ecenter weathermap'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/settings/ecenter'] = array(
    'title' => 'E-Center Weathermap',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ecenter_weathermap_admin_form'),
    'access callback' => 'user_access',
    'access arguments' => array('administer ecenter weathermap'),
    'description' => 'Configure the E-Center weather map.',
    'file' => 'ecenter_weathermap.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Implementation of hook_perm().
 */
function ecenter_weathermap_perm() {
  return array('access ecenter weathermap', 'administer ecenter weathermap', 'debug ecenter weathermap');
}

/**
 * Implementation of hook_theme().
 */
function ecenter_weathermap_theme() {
  $options = array(
    'file' => 'ecenter_weathermap.theme.inc',
    'path' => drupal_get_path('module', 'ecenter_weathermap') .'/theme',
  );
  $registry = array(
    'ecenter_weathermap_hop_option' => array(
      'arguments' => array(
        'hop' => NULL,
      )
    ) + $options,
   'ecenter_weathermap_data' => array(
      'template' => 'ecenter-weathermap-data',
      'arguments' => array(
        'data' => NULL,
        'params' => NULL,
      )
    ) + $options,
    'ecenter_weathermap_table' => array(
      'arguments' => array(
        'header' => NULL,
        'rows' => NULL,
        'attributes' => NULL,
        'caption' => NULL,
      ),
    ) + $options,
    'ecenter_weathermap_render_data_snmp' => array(
      'arguments' => array(
        'data' => NULL,
      ),
    ) + $options,
    'ecenter_weathermap_render_data_end_to_end_table' => array(
      'arguments' => array(
        'data' => NULL,
      ),
    ) + $options,
    'ecenter_weathermap_utilization_table' => array(
      'arguments' => array(
        'hop' => NULL,
        'direction' => NULL,
        'table' => NULL,
      ),
    ) + $options,

  );
  return $registry;
}

/**
 * Implementation of hook_init().
 */
function ecenter_weathermap_init() {

  if (arg(0) == 'weathermap' && !arg(1)) {
    // Force load OL
    openlayers_include();
    drupal_add_js(drupal_get_path('module', 'openlayers') .
      '/includes/layer_types/js/raw.js');

    // We need quickselect to get added to behaviors first, so when ensure it executes first
    //drupal_add_js(drupal_get_path('module', 'quickselect') .'/js/quickselect-behavior.js');

    // Also need the jquery form library
    drupal_add_js('misc/jquery.form.js');

    // Add jqPlot
    $jq_path = drupal_get_path('module', 'jqplot');
    drupal_add_js($jq_path .'/jqplot/excanvas.min.js');
    drupal_add_js($jq_path .'/jqplot/jquery.jqplot.js');

    // jqPlot plugins
    drupal_add_js($jq_path .'/jqplot/plugins/jqplot.dateAxisRenderer.js');
    drupal_add_js($jq_path .'/jqplot/plugins/jqplot.highlighter.js');
    drupal_add_js($jq_path .'/jqplot/plugins/jqplot.cursor.js');
    drupal_add_js($jq_path .'/jqplot/plugins/jqplot.canvasTextRenderer.js');
    drupal_add_js($jq_path .'/jqplot/plugins/jqplot.canvasAxisLabelRenderer.js');
    drupal_add_js(drupal_get_path('module', 'ecenter_weathermap') .'/js/jqplot/jqplot.linehighlighter.js');

    // Our libraries and behaviors
    drupal_add_js($jq_path .'/js/jquery.uuid.js');
    drupal_add_js($jq_path .'/js/jquery.tablechart.js');
    drupal_add_js($jq_path .'/js/jqplot-behaviors.js');

    // Query UI behaviors and libraries
    drupal_add_js(drupal_get_path('module', 'ecenter_weathermap') .'/js/jquery.metadata.js');
    drupal_add_js(drupal_get_path('module', 'ecenter_weathermap') .'/js/jquery.datehide.js');
    drupal_add_js(drupal_get_path('module', 'ecenter_weathermap') .'/js/jquery.traceroute.js');
    drupal_add_js(drupal_get_path('module', 'ecenter_weathermap') .'/js/behaviors.js');

    // Additional CSS overrides
    drupal_add_css(drupal_get_path('module', 'ecenter_weathermap') .'/css/plot.css');

    $inline_css = array(
      '.ecenter-critical' => array('color' => variable_get('ecenter_weathermap_threshold_critical_color', '#cc0000')),
      '.ecenter-marginal' => array('color' => variable_get('ecenter_weathermap_threshold_marginal_color', '#fe890c')),
      '.ecenter-good' => array('color' => variable_get('ecenter_weathermap_threshold_marginal_color', '#1c8a24')),
    );
    inline_css_add_css($inline_css);
  }
}

/**
 * Primary selection form definition.
 */
function _ecenter_weathermap_select_form() {
  global $user;

  // Initialize time-related variables
  $inc = variable_get('ecenter_weathermap_time_increment', 5);
  $now = time();
  $default_end = variable_get('ecenter_weathermap_default_end', 1800);
  $default_start = variable_get('ecenter_weathermap_default_end', 9000);
  $tz = date_default_timezone_name(TRUE);
  $end = date_make_date($now - $default_end, $tz, DATE_UNIX);
  $start = date_make_date($now - $default_start, $tz, DATE_UNIX);

  // Set up quick select options
  $quickselect_options = array(
    'emulateDropdown' => TRUE,
    'maxHeight' => '400px',
    'exactMatch' => TRUE,
  );

  if (user_access('debug ecenter weathermap')) {
    $form['debug'] = array(
      '#value' => '<div id="weathermap-debug"></div>',
    );
  }

  // Select source and destination IP -- convoluted because of AHAH
  $form['ip_select'] = array(
    '#prefix' => '<div id="ip-select-wrapper" class="clearfix">',
    '#suffix' => '</div>',
  );

  // Date select
  $form['ip_select']['date_wrapper'] = array(
    '#prefix' => '<div id="date-wrapper" class="clearfix">',
    '#suffix' => '</div>',
  );
  $form['ip_select']['date_wrapper']['start'] = array(
    '#type' => 'date_popup',
    '#title' => t('Start date'),
    '#date_increment' => $inc,
    '#default_value' => date_format($start, 'Y-m-d H:i'),
  );
  $form['ip_select']['date_wrapper']['end'] = array(
    '#type' => 'date_popup',
    '#title' => t('End date'),
    '#date_increment' => $inc,
    '#default_value' => date_format($end, 'Y-m-d H:i'),
  );
  $form['ip_select']['date_wrapper']['description'] = array(
    '#prefix' => '<div id="description-wrapper">',
    '#suffix' => '</div>',
    '#value' => '<p class="small">'. t('The time specified is expressed in your local time zone (@tz). You may change your timezone on your !link.',
      array('@tz' => date_default_timezone_name(TRUE), '!link' => l('user profile', 'user/'. $user->uid .'/edit'))) .'</p>',
  );

  // Source IP
  $form['ip_select']['src_wrapper'] = array(
    '#prefix' => '<div id="src-wrapper">',
    '#suffix' => '</div>',
  );
  $form['ip_select']['src_wrapper']['src'] = array(
    '#title' => t('Source'),
    '#type' => 'combobox',
    '#cols' => 50,
    '#required' => TRUE,
    '#options' => array('' => t('Select a source')),
    //'#quickselect_options' => $quickselect_options,
    '#ahah' => array(
      'event' => 'change',
      'path' => ahah_helper_path(array('ip_select', 'dst_wrapper', 'dst')),
      'wrapper' => 'dst-wrapper',
    ),
  );

  // Destination IP
  $form['ip_select']['dst_wrapper'] = array(
    '#prefix' => '<div id="dst-wrapper">',
    '#suffix' => '</div>',
  );
  $form['ip_select']['dst_wrapper']['dst'] = array(
    '#title' => t('Destination'),
    '#type' => 'combobox',
    '#cols' => 50,
    '#required' => FALSE,
    '#disabled' => TRUE,
    '#options' => array('' => t('Select a destination')),
    //'#quickselect_options' => $quickselect_options,
    '#prefix' => '<div class="dst-wrapper">',
    '#suffix' => '</div>',
    '#ahah' => array(
      'event' => 'change',
      'path' => ahah_helper_path(array('results_wrapper', 'results')),
      'wrapper' => 'results-wrapper',
    ),
  );

  // Map
  $preset = openlayers_preset_load('ecenter_weathermap');
  $map = openlayers_render_map($preset->data, $preset->name);

  // Network map
  $form['weathermap_wrapper'] = array(
    '#prefix' => '<div id="weathermap-wrapper" class="clearfix">',
    '#suffix' => '</div>',
  );
  $form['weathermap_wrapper']['weathermap'] = array(
    '#prefix' => '<div id="weathermap-map">',
    '#value' => $map,
    '#suffix' => '</div>',
  );
  $form['weathermap_wrapper']['end_to_end_results'] = array(
    '#prefix' => '<div id="weathermap-end-to-end-results">',
    '#value' => t('Click a source and destination on the map to get path statistics (currently not functional!), or select source and destination using the form above.'),
    '#suffix' => '</div>',
  );

  // Submit button
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
    '#attributes' => array('class' => 'no-js'),
  );

  // Data results display
  $form['results_wrapper'] = array(
    '#prefix' => '<div id="results-wrapper">',
    '#suffix' => '</div>',
  );
  $form['results_wrapper']['results'] = array(
    '#value' => '&nbsp;',
  );

  // For ahah helper
  $form['#tree'] = TRUE;

  return $form;
}

/**
 * Primary selection form.
 *
 * The basic form is defined in _ecenter_weathermap_select_form. This function
 * primarily processes the form.
 */
function ecenter_weathermap_select_form(&$form_state) {

  // Get base form and register with ahah_helper
  $form = _ecenter_weathermap_select_form();
  ahah_helper_register($form, $form_state);

  // Add ahah_helper override
  drupal_add_js(drupal_get_path('module', 'ecenter_weathermap') .'/js/ahah.js', 'footer');

  // Get variables
  extract(_ecenter_weathermap_extract_query());

  // Set dates
  if (!empty($start)) {
    $form['ip_select']['date_wrapper']['start']['#default_value'] = $start;
  }
  if (!empty($end)) {
    $form['ip_select']['date_wrapper']['end']['#default_value'] = $end;
  }

  $hops = ecenter_weathermap_get_hops();
  foreach ($hops['hops'] as $key => $hop) {
    $src_options[$key] = theme('ecenter_weathermap_hop_option', $hop);
  }
  $form['ip_select']['src_wrapper']['src']['#options'] += $src_options;

  if ($src) {
    $form['ip_select']['src_wrapper']['src']['#default_value'] = $src;

    foreach ($hops['hops'] as $key => $hop) {
      $dst_options[$key] = theme('ecenter_weathermap_hop_option', $hop);
    }
    $form['ip_select']['dst_wrapper']['dst']['#options'] += $dst_options;
    $form['ip_select']['dst_wrapper']['dst']['#disabled'] = FALSE;
  }

  if ($dst) {
    $form['ip_select']['dst_wrapper']['dst']['#default_value'] = $dst;
  }

  if ($src && $dst && $start && $end) {

    $start_adjusted = _ecenter_weathermap_date_to_utc($start);
    $end_adjusted = _ecenter_weathermap_date_to_utc($end);

    $data = ecenter_weathermap_get_data($src, $dst, $start_adjusted, $end_adjusted);

    $params = array(
      'src' => $src,
      'dst' => $dst,
      'start' => $start_adjusted,
      'end' => $end_adjusted,
    );

    // If we've got the data (at bare minimum, a traceroute), delegate to rendering function
    //if ($data) {
      drupal_add_js(array('ecenterWeathermap' => array('tracerouteData' => $data['js_diff'])), 'setting');
      drupal_add_js(array('ecenterWeathermap' => array('tracerouteMaxLength' => $data['traceroute_max'])), 'setting');
      drupal_add_js(array('ecenterWeathermap' => array('seriesLookup' => $data['series_lookup'])), 'setting');
      ecenter_weathermap_refresh_map('ecenter_weathermap', 'openlayers-map-auto-id-0');
      $form['results_wrapper']['results']['#value'] = theme('ecenter_weathermap_data', $data, $params);
    /*}
    else {
      watchdog('ecenter', 'Query returned no results: <code>@query</code>', array('@query' => $query), WATCHDOG_INFO);
      $form['results_wrapper']['results']['#value'] = '<p>'. t('Whoops! No data was available for this query. If you believe there should be data for this query, send the site administrator feedback along with executed query, provided below:') .'</p>';
      $form['results_wrapper']['results']['#value'] .= '<pre>'. $query .'</pre>';
      $form['results_wrapper']['results']['#value'] .= '<p>'. l(t('Permalink'), 'weathermap', array('query' => $query_params)) .'</p>';
    }*/
  }
  return $form;
}

/**
 * Default submit handler for weathermap form
 */
function ecenter_weathermap_select_form_submit($form, &$form_state) {
  // Do what AHAH helper does on an AJAX call, to make form constructor a 
  // little less crazy
  $form_state['storage'] = $form_state['values'];
  $form_state['rebuild'] = TRUE;
}

/**
 * Get the E-Center weather map client
 *
 * @param $status_check
 *  '503', 'message', or FALSE.  What to do if status_check fails.
 */
function ecenter_weathermap_get_client($status_check = '503') {
  static $client = FALSE;
  return TRUE;
  if (!$client) {
    require_once(dirname(__FILE__) . '/client.php');
    $host = variable_get('ecenter_weathermap_host', 'localhost');
    $port = variable_get('ecenter_weathermap_port', 8000);
    $dir = variable_get('ecenter_weathermap_basedir', '');
    $timeout = variable_get('ecenter_weathermap_timeout', 30);
    $status_timeout = variable_get('ecenter_weathermap_status_timeout', 2);
    $client = new Ecenter_Data_Service_Client($host, $port, $dir, $timeout, $status_timeout);
  }

  // Check status
  if ($status_check && !$client->checkStatus()) {
    $message = t('E-Center web service is not available.');
    watchdog('ecenter', $message, array(), WATCHDOG_ERROR);

    if ($status_check == '503') {
      drupal_set_header('HTTP/1.1 503 Service unavailable');
      // Keep old path for reference, and to allow forms to redirect to it.
      if (!isset($_REQUEST['destination'])) {
        $_REQUEST['destination'] = $_GET['q'];
      }
      print theme('page', $message);
      exit();
    }
    else {
      drupal_set_message($message);
    }
  }
  return $client;
}

/**
 * Get/cache data
 *
 * @param $src
 *   Source IP address
 * @param $dst
 *   Destination IP address
 * @param $start
 *   Start time
 * @param $end
 *   End time
 * @return
 *   An array of parsed data
 */
function ecenter_weathermap_get_data($src, $dst, $start, $end, $debug_url = FALSE) {
  static $results = array();

  $query = http_build_query(array(
    'src' => $src,
    'dst' => $dst,
    'start' => $start,
    'end' => $end,
  ));

  if (!array_key_exists($query, $results)) {
    $caching = variable_get('ecenter_weathermap_data_cache_enabled', 0);
    if ($caching && $result = cache_get($query, 'cache_ecenter_data')) {
      $results[$query] = $result->data;
    }
    else {
      $client = ecenter_weathermap_get_client('message');
      $result = $client->getData($src, $dst, $start, $end);
      if ($result['code'] == 200) {
        $data = ecenter_weathermap_parse_response($result, $src, $dst);
        if ($caching) {
          $expires = time() + variable_get('ecenter_weathermap_data_cache_ttl', 300);
          cache_set($query, $data, 'cache_ecenter_data', $expires);
        }
        $results[$query] = $data;
      }
      else { // Note that the static variable is NOT set in this case
        drupal_set_message(t('Request failed with code @code.', array('@code' => $result['code'])));
      }
    }
  }
  return $results[$query];
}

/**
 * Get hops
 *
 * @param $src
 *   (optional) Source IP address to determine potential destinations.  If
     not supplied, list all potential source hops.
 * @return
 *   An array of hop objects.
 */
function ecenter_weathermap_get_hops($src = NULL) {
  static $hops = array();
  $src_key = (!empty($src)) ? $src : 'sources';

  if (empty($hops[$src_key])) {

    $caching = variable_get('ecenter_weathermap_hop_cache_enabled', 0);
    if ($caching && $result = cache_get('hub', 'cache_ecenter_hops')) {
      $hops = $result->data;
    }
    else {
      $client = ecenter_weathermap_get_client('message');
      //$result = $client->getHops();
      $result = _ecenter_weathermap_sources();
      if ($result['code'] == 200) {
        $data = ecenter_weathermap_parse_hops($result['response']);
        $hops[$src_key] = $data;
        if ($caching) {
          $expires = time() + variable_get('ecenter_weathermap_hop_cache_ttl', 600);
          cache_set($src_key, $data, 'cache_ecenter_hops', $expires);
        }
      }
      else {
        drupal_set_message(t('Request failed with code @code.', array('@code' => $result['code'])));
      }
    }
  }
  return $hops[$src_key];
}

/**
 * @TODO Delete, unneeded
 * Traverse an object, turning all members into arrays or preserving their
 * values.
 */
function _ecenter_weathermap_object_to_array($obj) {
  if (is_object($obj)) {
    $obj = get_object_vars($obj);
  }
  foreach ($obj as $k => $v) {
    if (is_object($v) || is_array($v)) {
      $obj[$k] = _ecenter_weathermap_object_to_array($v);
    }
    else {
      $obj[$k] = $v;
    }
  }
  return $obj;
}

/**
 * Return allowed data types
 */
function _ecenter_weathermap_get_data_types() {
  return array('snmp', 'pinger', 'owamp', 'bwctl');
}

/**
 * Parse data
 *
 * Parse and prep response from E-Center network data webservice:
 *  - Build an array with forward and reverse traceroutes, their hops, and associated data
 *  - Geolocate IP addresses without geodata
 *
 * @param $response
 *   A response object from the E-center webservice.
 * @return
 *   A big, complicated array of E-center data
 */
function ecenter_weathermap_parse_response($response, $src, $dst) {
  $parsed_data = array();
  $data = $response['response'];
  $hops = ecenter_weathermap_get_hops();

  foreach (array('traceroute', 'reverse_traceroute') as $direction) {

    // We may not have ANY forward or reverse traceroutes
    if (empty($data[$direction])) {
      continue;
    }

    $parsed = array();

    // Sort and grab latest traceroute
    krsort($data[$direction]);
    $traceroute = array_shift(array_values($data[$direction]));

    // Synthesize forward and reverse hops
    if ($direction == 'traceroute') {
      $hub = array_shift(explode('-', $traceroute[0]['hub']));
      if ($hub != $src) {
        $new_hop = $hops[$src] + array(
          'hop_id' => uniqid('start-'),
          'hop_ip' => $src,
          'nodename' => $src,
          'netblock' => 'src',
        );
        array_unshift($traceroute, $new_hop);
      }

      $last = count($traceroute) -1;
      $hub = array_shift(explode('-', $traceroute[$last]['hub']));
      if ($hub != $dst) {
        $new_hop = $hops[$dst] + array(
          'hop_id' => uniqid('start-'),
          'hop_ip' => $dst,
          'nodename' => $dst,
          'netblock' => 'dst',
        );
        array_push($traceroute, $new_hop);
      }
    }
    elseif ($direction == 'reverse_traceroute') {
      $hub = array_shift(explode('-', $traceroute[0]['hub']));
      if ($hub != $src) {
        $new_hop = $hops[$src] + array(
          'hop_id' => uniqid('start-'),
          'hop_ip' => $src,
          'nodename' => $src,
          'netblock' => 'src',
        );
        array_unshift($traceroute, $new_hop);
      }

      $last = count($traceroute) -1;
      $hub = array_shift(explode('-', $traceroute[$last]['hub']));
      if ($hub != $dst) {
        $new_hop = $hops[$dst] + array(
          'hop_id' => uniqid('start-'),
          'hop_ip' => $dst,
          'nodename' => $dst,
          'netblock' => 'dst',
        );
        array_push($traceroute, $new_hop);
      }
    }

    // Main loop
    foreach ($traceroute as $hop) {
      $hop_data = array();

      // Geolocate IP if no geo data available
      if (!$hop['longitude'] || !$hop['latitude']) {
        $geo = geoip_city($hop['hop_ip']);
        $hop['longitude'] = $geo->longitude;
        $hop['latitude'] = $geo->latitude;
        $hop['geolocated'] = TRUE;
      }

      // SNMP
      $hop_data['snmp'] = $data['snmp'][$hop['hop_id']];

      // Calculate netblock
      if ($hop['netblock'] != 'src' && $hop['netblock'] != 'dst') {
        $mask = (!empty($hop['netmask'])) ? $hop['netmask'] : 24;
        $hop['netblock'] = long2ip(ip2long($hop['hop_ip']) & ~((1 << (32 - $mask)) - 1));
      }

      $parsed[] = array(
        'hop' => $hop,
        'data' => $hop_data,
      );
    }

    $direction_label = ($direction == 'reverse_traceroute') ? 'reverse' : 'forward';
    $parsed_data[$direction_label] = $parsed;
  }

  // End to end
  $end_to_end = array();
  $src_netblock = long2ip(ip2long($src) & ~((1 << 8) - 1));
  $dst_netblock = long2ip(ip2long($dst) & ~((1 << 8) - 1));

  foreach (array('bwctl', 'owamp', 'pinger') as $type) {
    if (!is_array($data[$type])) {
      continue;
    }

    // @TODO investigate potential problems with this approach...
    $end_to_end[$type] = array('forward' => array(), 'reverse' => array());

    foreach ($data[$type] as $test_src => $destinations) {
      $test_src_netblock = long2ip(ip2long($test_src) & ~((1 << 8) - 1));
      if ($test_src_netblock == $src_netblock) {
        foreach ($destinations as $test_dst => $test_data) {
          $end_to_end[$type]['forward'] += $test_data;
        }
      }
      if ($test_src_netblock == $dst_netblock) {
        foreach ($destinations as $test_src => $test_data) {
          $end_to_end[$type]['reverse'] += $test_data;
        }
      }
    }

  }

  if (!empty($end_to_end)) {  
    $parsed_data['end_to_end'] = $end_to_end;
  }

  // Calculate diff
  if (!empty($parsed_data['forward']) && !empty($parsed_data['reverse'])) {
    $forward = $parsed_data['forward'];
    $reverse = array_reverse($parsed_data['reverse']);

    $parsed_data['diff'] = ecenter_weathermap_traceroute_diff($forward, $reverse);
    $parsed_data['traceroute_max'] = (count($forward) > count($reverse)) ? count($forward) : count($reverse);
  }
  elseif (!empty($parsed_data['forward'])) {
    $diff = array();
    $forward = $parsed_data['forward'];
    foreach ($forward as $row) {
      $diff[] = array('match' => array('forward' => array($row)));
    }
    $parsed_data['diff'] = $diff;
  }
  elseif (!empty($parsed_data['reverse'])) {
    $diff = array();
    $reverse = $parsed_data['reverse'];
    foreach ($reverse as $row) {
      $diff[] = array('match' => array('reverse' => array($row)));
    }
    $parsed_data['diff'] = $diff;
  }

  // Recreate diff without hop data
  if (!empty($parsed_data['forward']) && !empty($parsed_data['reverse'])) {
    $js_diff = array();
    foreach ($parsed_data['diff'] as $row) {
      foreach ($row as $type => $directions) {
        $new_row = array();
        foreach ($directions as $direction => $hops) {
          $new_hops = array();
          foreach ($hops as $hop) {
            $has_data = FALSE;
            foreach ($hop['data'] as $hop_data) {
              if (!empty($hop_data)) {
                $has_data = TRUE;
                $j++;
              }
            }
            $new_hops[] = array(
              'hop' => $hop['hop'],
              'data' => $has_data,
            );
          }

          $new_row[$direction] = $new_hops;
        }
        $js_diff[] = array(
          $type => $new_row,
        );
      }
    }
    $parsed_data['js_diff'] = $js_diff;

    // Finally, parse JS Diff to create a structure linking hop IDs to series
    $series_by_id = array();
    $series_by_idx = array();

    $i = 0;
    foreach ($js_diff as $row) {
      if (!empty($row['match'])) {
        if ($row['match']['forward'][0]['data']) {
          $series_by_id[$row['match']['forward'][0]['hop']['hop_id']] = array(
            'idx' => $i,
            'corresponding_id' => $row['match']['reverse'][0]['hop']['hop_id'],
            'corresponding_idx' => $i + 1,
          );
          $series_by_idx[] = array(
            'id' => $row['match']['forward'][0]['hop']['hop_id'],
            'corresponding_id' => $row['match']['reverse'][0]['hop']['hop_id'],
            'corresponding_idx' => $i + 1,
          );
          $i++;
        }
        if ($row['match']['reverse'][0]['data']) {
          $series_by_id[$row['match']['reverse'][0]['hop']['hop_id']] = array(
            'idx' => $i,
            'corresponding_id' => $row['match']['forward'][0]['hop']['hop_id'],
            'corresponding_idx' => $i - 1,
          );
          $series_by_idx[] = array(
            'id' => $row['match']['reverse'][0]['hop']['hop_id'],
            'corresponding' => $row['match']['forward'][0]['hop']['hop_id'],
            'corresponding_idx' => $i + 1,
          );
          $i++;
        }
      }
      if (!empty($row['diff'])) {
        foreach (array('forward', 'reverse') as $direction) {
          foreach ($row['diff'][$direction] as $hop) {
            if ($hop['data']) {
              $series_by_id[$hop['hop']['hop_id']] = array(
                'idx' => $i,
              );
              $series_by_idx[] = array(
                'id' => $hop['hop']['hop_id'],
              );
              $i++;
            }
          }
        }
      }
    }
    $parsed_data['series_lookup'] = array('id' => $series_by_id, 'idx' => $series_by_idx);
  }

  return $parsed_data;
}

/**
 * Parse hops
 * 
 * @param $hop_list
 *  List of hops returns from data service
 * @return 
 *  Parsed array consisting of hubs and hops
 */
function ecenter_weathermap_parse_hops($hop_list) {
  $hops = array();
  $hubs = array();

  usort($hop_list, '_ecenter_weathermap_sort_hopname');

  foreach ($hop_list as $hop) {
    // First instance of hub
    if (empty($hubs[$hop['hub_name']])) {
      $hubs[$hop['hub_name']] = $hop;
      $hops['hub:'. $hop['hub_name']] = $hop + array('type' => 'hub');
    }

    $hops['ip:'. $hop['ip_noted']] = $hop + array('type' => 'ip');
  }
  
  return array('hops' => $hops, 'hubs' => $hubs);
}

/**
 * Callback for custom hop sort
 */
function _ecenter_weathermap_sort_hopname($a, $b) {
  return strcmp($a['hub'], $b['hub']);
}

/**
 * Implementation of hook_jqplot_plugins().
 */
function ecenter_weathermap_jqplot_plugins() {
  $path = drupal_get_path('module', 'ecenter_weathermap') .'/js/jqplot';
  return array(
    'linehighlighter' => $path .'/jqplot.linehighlighter.js',
  );
}

/**
 * Implementation of hook_ctools_plugin_api().
 * Required to provide layers
 */
function ecenter_weathermap_ctools_plugin_api($module, $api) {
  if ($module == "openlayers") {
    switch ($api) {
      case 'openlayers_layers':
      case 'openlayers_styles':
      case 'openlayers_presets':
        return array('version' => 1);
    }
  }
}

/**
 * Implementation of hook_openlayers_presets().
 */
function ecenter_weathermap_openlayers_presets() {

  $items = array();
  $openlayers_presets = new stdClass;
  $openlayers_presets->disabled = FALSE; /* Edit this to true to make a default openlayers_presets disabled initially */
  $openlayers_presets->api_version = 1;
  $openlayers_presets->name = 'ecenter_weathermap';
  $openlayers_presets->title = 'E-Center Weathermap';
  $openlayers_presets->description = 'E-Center network weathermap';
  $openlayers_presets->data = array(
    'width' => '660px',
    'height' => '360px',
    //'image_path' => 'http://js.mapbox.com/theme/dark/',
    'css_path' => '',
    'proxy_host' => '',
    'hide_empty_map' => 0,
    'center' => array(
      'initial' => array(
        'centerpoint' => '-97.892187496064, 38.822590974865',
        'zoom' => '4',
      ),
      'restrict' => array(
        'restrictextent' => 0,
        'restrictedExtent' => '',
      ),
    ),
    'behaviors' => array(
      'ecenter_weathermap_behavior_dynamicload' => array(),
      'openlayers_behavior_fullscreen' => array(
        'activated' => 0,
      ),
      'openlayers_behavior_navigation' => array(
        'zoomWheelEnabled' => 0,
      ),
      'openlayers_behavior_panzoombar' => array(),
    ),
    'default_layer' => 'osm_mapnik',
    'layers' => array(
      'osm_mapnik' => 'osm_mapnik',
      'ecenter_weathermap_sites' => 'ecenter_weathermap_sites',
    ),
    'layer_activated' => array(
      'ecenter_weathermap_sites' => 'ecenter_weathermap_sites',
    ),
    'projection' => '900913',
    'displayProjection' => '4326',
    'styles' => array(
      'default' => 'ecenter_default',
      'select' => 'ecenter_selected',
      'temporary' => 'default',
    ),
    'preset_name' => 'ecenter_weathermap',
  );
  $items["ecenter_weathermap"] = $openlayers_presets;
  return $items;
}

/**
 * Implementation of hook_openlayers_styles().
 */
function ecenter_weathermap_openlayers_styles() {
  $styles = array();

  // Default
  $style = new stdClass();
  $style->api_version = 1;
  $style->name = 'ecenter_default';
  $style->title = t('E-center style');
  $style->description = t('Basic e-center style.');
  $style->data = array(
    'pointRadius' => 6,
    'fillColor' => '#ffffff',
    'strokeColor' => '#0000aa',
    'strokeWidth' => 2,
    'fillOpacity' => 1,
  );
  $styles[$style->name] = $style;

  // Selected
  $style = new stdClass();
  $style->api_version = 1;
  $style->name = 'ecenter_selected';
  $style->title = t('E-center selected style');
  $style->description = t('Basic e-center style.');
  $style->data = array(
    'pointRadius' => 6,
    'fillColor' => '#ffffff',
    'strokeColor' => '#777777',
    'strokeWidth' => 2,
    'fillOpacity' => 1,
  );
  $styles[$style->name] = $style;

  return $styles;
}

/**
 * Implementation of hook_openlayers_behaviors().
 */
function ecenter_weathermap_openlayers_behaviors() {
  return array(
    'ecenter_weathermap_behavior_dynamicload' => array(
      'title' => t('E-Center Weathermap: Dynamic Load'),
      'behavior' => array(
        'path' => drupal_get_path('module', 'ecenter_weathermap') .'/openlayers',
        'file' => 'ecenter_weathermap_behavior_dynamicload.inc',
        'class' => 'ecenter_weathermap_behavior_dynamicload',
        'parent' => 'openlayers_behavior',
      ),
    ),
  );
}

/**
 * Implementation of hook_openlayers_layers().
 */
function ecenter_weathermap_openlayers_layers() {
  $layers = array(
    'ecenter_weathermap_sites' => ecenter_weathermap_layers_sites(),
  );

  // Provide dynamic layers for map on
  if ((arg(0) == 'weathermap' && !arg(1)) || ($_REQUEST['form_id'] == 'ecenter_weathermap_select_form')) {
    $layers += ecenter_weathermap_layers_traceroute();
  }
  return $layers;
}

/**
 * Generate traceroute 
 */
function ecenter_weathermap_layers_sites() {
  $hops = ecenter_weathermap_get_hops();

  // Create layer object
  $layer = new stdClass();
  $layer->api_version = 1;
  $layer->name = 'ecenter_weathermap_sites';
  $layer->title = t('Traceroute @id', array('@id' => $trace_id));
  $layer->description = '';
  $layer->data = array(
    'layer_type' => 'openlayers_layer_type_raw',
    'projection' => array('900913'),
  );

  foreach ($hops['hubs'] as $hub) {
    $features[] = array(
      'wkt' => "POINT({$hub['longitude']} {$hub['latitude']})",
      'projection' => "4326",
      'style' => array(
        'pointRadius' => 6,
        'fillColor' => '#ffffff',
        'fillOpacity' => .6,
        'strokeColor' => '#0000aa',
        'strokeWidth' => 3,
        'strokeOpacity' => .6,
        'label' => $hub['hub_name'],
        'labelYOffset' => -20,
        'fontWeight' => 'bold',
        'fontFamily' => '"Droid Sans", "Helvetica Neue", Helvetica, Verdana, sans-serif',
        'fontColor' => '#555555',
      ),
    );
  }

  $layer->data['features'] = $features;
  return $layer;
}

/**
 * Generate dynamic raw layer data for E-center weathermap
 */
function ecenter_weathermap_layers_traceroute() {
  $layers = array();
  extract(_ecenter_weathermap_extract_query());

  if ($src && $dst && $start && $end) {

    $start_date_adjusted = _ecenter_weathermap_date_to_utc($start);
    $end_date_adjusted = _ecenter_weathermap_date_to_utc($end);

    $data = ecenter_weathermap_get_data($src, $dst, $start_date_adjusted, $end_date_adjusted);

    if ($data && $traceroute = $data['forward']) {

      // Initialize some counters, etc
      $old_hop = NULL;
      $count = count($traceroute);
      $i = 0;

      // Create layer object
      $layer = new stdClass();
      $layer->api_version = 1;
      $layer->name = 'ecenter_weathermap_traceroute';
      $layer->title = t('Traceroute @id', array('@id' => $trace_id));
      $layer->description = '';
      $layer->data = array(
        'layer_type' => 'openlayers_layer_type_raw',
        'projection' => array('900913'),
      );

      $features = array();
      foreach ($traceroute as $hop_data) {
        $hop = $hop_data['hop'];
        if ($hop['longitude'] && $hop['latitude']) {
          if ($old_hop && $i < $count) {
            $curve = _ecenter_weathermap_curve($old_hop, $hop, $index, $flip);
            $segments = array();
            foreach ($curve as $segment) {
              $segments[] = "{$segment->x} {$segment->y}";
            }

            $line = implode(',', $segments);

            $features[] = array(
              'wkt' => "LINESTRING($line)",
              'projection' => "4326",
              'style' => array(
                'strokeWidth' => 4,
                'strokeColor' => '#444444',
                'strokeOpacity' => '0.75',
              ),
            );
          }
          $features[] = array(
            'wkt' => "POINT({$hop['longitude']} {$hop['latitude']})",
            'projection' => "4326",
            'style' => array(
              'pointRadius' => 5,
              'fillColor' => '#ffffff',
              'strokeColor' => '#0000aa',
              'strokeWidth' => 2,
              'fillOpacity' => 1,
            ),
          );
        }
        $old_hop = $hop;
        $i += 1;

        $layer->data['features'] = $features;
        $layers[$layer->name] = $layer;
      }
    }
  }
  return $layers;
}

/**
 * Create a curve the E-center weathermap
 *
 * @param $from
 *   Array consisting with keys for latitude and longitude
 * @param $to
 *   Array consisting with keys for latitude and longitude
 * @param $index
 *   An integer scaling factor for the control points used
 * @param $flip
 *   Boolean: If true, flip curve upside down
 * @return
 *   An array of points on the curve
 */
function _ecenter_weathermap_curve($from, $to, $index = 0, $flip = FALSE) {
  $p0 = new Vector2d($from['longitude'], $from['latitude']);
  $p3 = new Vector2d($to['longitude'], $to['latitude']);

  // Base control point angle and magnitude on index
  $angle = pi() * (1 + (0.25 * $index)) / 8;
  $magnitude = (1.5 + 0.5 * $index) / 8;

  list($c1, $c2) = _ecenter_weathermap_get_control_points($p0, $p3, $magnitude, $angle, $flip);

  $steps = variable_get('ecenter_weathermap_curve_divisions', 20);
  return _ecenter_weathermap_get_bezier($p0, $c1, $c2, $p3, $steps);
}

/**
 * Create a bezier curve
 *
 * Calculate a bezier curve using the standard bezier algorithm.
 *
 * @param $p0
 *   Endpoint 1
 * @param $c1
 *   Control point 1
 * @param $c2
 *   Control point 2
 * @param $p3
 *   Endpoint 2
 * @param $steps
 *   Number of steps (i.e. segments) to take
 * @return
 *  An array of points on the curve
 */
function _ecenter_weathermap_get_bezier($p0, $c1, $c2, $p3, $steps) {
  $div = 1 / $steps;

  for ($t = 0; $t <= 1; $t += $div) {
    // Coefficients
    $B0 = pow($t, 3);
    $B1 = 3 * pow($t, 2) * (1 - $t);
    $B2 = 3 * $t * pow((1 - $t), 2);
    $B3 = pow((1 - $t), 3);

    // Coordinates
    $x = ($p0->x * $B0) + ($c1->x * $B1) + ($c2->x * $B2) + ($p3->x * $B3);
    $y = ($p0->y * $B0) + ($c1->y * $B1) + ($c2->y * $B2) + ($p3->y * $B3);

    $point = new Vector2d($x, $y);
    $points[] = $point;
  }
  $points[] = $p0; // I don't really understand why I need this
  return $points;
}

/**
 * Get control points
 *
 * Calculate control points for drawing Bezier curve between points
 *
 * @param $from
 *   Source coordinates
 * @param $to
 *   Destination coordinates
 * @param $mag_scale
 *   A scaling factor for the control point vector
 * @param $angle
 *   The angle of control point vector relative to the line
 *   between source and destination.
 * @return
 *   Array of control points
 */
function _ecenter_weathermap_get_control_points($to, $from, $mag_scale, $angle, $flip = FALSE) {
  $dirX = $to->x - $from->x;
  $dirY = $to->y - $from->y;

  $mag = sqrt(($dirX * $dirX) + ($dirY * $dirY));
  if (!$mag) {
    return array($to, $from);
  }

  $length = $mag * $mag_scale;

  $dirX = $dirX / $mag;
  $dirY = $dirY / $mag;

  $sin = sin($angle);
  $cos = cos($angle);

  $rotX = $cos * $dirX - $sin * $dirY;
  $rotY = $sin * $dirX + $cos * $dirY;
  $rotNegX = $cos * -$dirX - $sin * $dirY;
  $rotNegY = $sin * $dirX - $cos * $dirY;

  // Flip control points for "backwards" curves
  if (!$flip && ($dirX < 0 || (!$dirX && $dirY < 0))) {
    $x1 = -$rotNegX * $length + $from->x;
    $y1 = -$rotNegY * $length + $from->y;
    $x2 = -$rotX * $length + $to->x;
    $y2 = -$rotY * $length + $to->y;
  }
  // Or generate "normal" control points
  else {
    $x1 = $rotX * $length + $from->x;
    $y1 = $rotY * $length + $from->y;
    $x2 = $rotNegX * $length + $to->x;
    $y2 = $rotNegY * $length + $to->y;
  }

  return array(new Vector2d($x2, $y2), new Vector2d($x1, $y1));
}

/**
 * Implementation of hook_openlayers_map_alter().
 */
function ecenter_weathermap_openlayers_map_alter(&$map) {
  if ($map['preset_name'] == 'ecenter_weathermap') {
    foreach ($map['layers'] as $name => $layer) {
      if ($layer['baselayer'] == TRUE) {
        $map['layers'][$name]['numZoomLevels'] = 12;
      }
    }
  }
}

/**
 * Implementation of hook_openlayers_map_preprocess_alter().
 */
function ecenter_weathermap_openlayers_map_preprocess_alter(&$map) {
  // Add the new layers to the map array for our behavior to use
  if ($map['preset_name'] == 'ecenter_weathermap') {
    $client = ecenter_weathermap_get_client();

    // Get variables
    extract(_ecenter_weathermap_extract_query());

    if ($src && $dst && $start && $end) {
      $start_date_adjusted = _ecenter_weathermap_date_to_utc($start);
      $end_date_adjusted = _ecenter_weathermap_date_to_utc($end);

      $data = ecenter_weathermap_get_data($src, $dst, $start_date_adjusted, $end_date_adjusted);

      if ($data && !empty($data['forward'])) {
        $map['layers']['ecenter_traceroute'] = 'ecenter_traceroute';
        //$map['layer_switcher']['ecenter_traceroute'] = 'ecenter_traceroute';
        $map['layer_styles']['ecenter_traceroute'] = 'ecenter_default';
        $map['layer_activated']['ecenter_traceroute'] = 'ecenter_traceroute';
      }
    }
  }
  return $map;
}

/**
 * Refresh an Openlayers map
 *
 * This function is necessary because openlayers_render_map uses a small hack
 * and uses json_encode and adds map settings to the page header.  This
 * function adds the map array to the Drupal JS settings array no matter what,
 * so that AJAX/AHAH will work properly.
 *
 * @param $preset
 *   A string preset name.
 * @param $id
 *   Optional ID to use for map.
 */
function ecenter_weathermap_refresh_map($preset, $id = NULL) {
  openlayers_include();
  $preset = openlayers_preset_load($preset);

  // Run map through build process
  $map = openlayers_build_map($preset->data);
  $map['id'] = (!empty($id)) ? $id : $map['id'];

  // Set proper JS settings
  if (empty($map['errors'])) {
    $js = array('openlayers' => array('maps' => array($map['id'] => $map)));
    drupal_add_js($js, 'setting');
  }
}

/**
 * Adjust local date to UTC
 *
 * @param $date
 *   A date string
 * @param $format
 *   Format to use for return value.
 * @return string
 *   Formatted, converted date
 */
function _ecenter_weathermap_date_to_utc($date, $format = 'Y-m-d H:i:s') {
  $tz = date_default_timezone_name(TRUE);
  $adjusted = date_create($date, timezone_open($tz));
  date_timezone_set($adjusted, timezone_open('UTC'));
  return date_format($adjusted, $format);
}

/**
 * Package query variables as an array
 *
 * E-Center queries can come from form input, or query string variables.  Let's
 * not worry about WHERE they came from during data processing.  Typically, you
 * should invoke by extract()ing the contents of the array.
 *
 * @return array
 *  An array of query values
 */
function _ecenter_weathermap_extract_query() {
  if ($_REQUEST['form_id'] == 'ecenter_weathermap_select_form') {
    $vars = array(
      'src' => $_REQUEST['ip_select']['src_wrapper']['src'],
      'dst' => $_REQUEST['ip_select']['dst_wrapper']['dst'],
      'start' => $_REQUEST['ip_select']['date_wrapper']['start']['date'] .' '. $_REQUEST['ip_select']['date_wrapper']['start']['time'],
      'end' => $_REQUEST['ip_select']['date_wrapper']['end']['date'] .' '. $_REQUEST['ip_select']['date_wrapper']['end']['time'],
    );
  }
  else {
    $vars = array(
      'src' => $_REQUEST['src'],
      'dst' => $_REQUEST['dst'],
      'start' => $_REQUEST['start'],
      'end' => $_REQUEST['end'],
    );
  }
  return $vars;
}

/**
 * @TODO Remove
 * @TEMPORARY
 */
function _ecenter_weathermap_sources() {
  return array(
    'code' => 200,
    'response' => json_decode('
      [{
      "longitude":"-88.262",
      "hub":"fnal-cr1",
      "hub_name":"FNAL",
      "nodename":"lhc-dmz-latency.deemz.net",
      "ip_noted":"198.49.208.3",
      "latitude":"41.8382",
      "netmask":"24"
      },
      {
      "longitude":"-72.8805",
      "hub":"bnl-cr1",
      "hub_name":"BNL",
      "nodename":"lhcperfmon.bnl.gov",
      "ip_noted":"192.12.15.26",
      "latitude":"40.8703",
      "netmask":"24"
      },
      {
      "longitude":"-122.252",
      "hub":"lbl-cr1",
      "hub_name":"LBL",
      "nodename":"nettest.lbl.gov",
      "ip_noted":"131.243.24.11",
      "latitude":"37.8769",
      "netmask":"24"
      },
      {
      "longitude":"-72.8805",
      "hub":"bnl-cr2",
      "hub_name":"BNL",
      "nodename":"lhcmon.bnl.gov",
      "ip_noted":"192.12.15.23",
      "latitude":"40.8703",
      "netmask":"24"
      },
      {
      "longitude":"-122.252",
      "hub":"lbl-cr2",
      "hub_name":"LBL",
      "nodename":"lblnet-test.lbl.gov",
      "ip_noted":"128.3.121.114",
      "latitude":"37.8769",
      "netmask":"24"
      },
      {
      "longitude":"-88.262",
      "hub":"fnal-cr2",
      "hub_name":"FNAL",
      "nodename":"lhc-dmz-bw.deemz.net",
      "ip_noted":"198.49.208.6",
      "latitude":"41.8382",
      "netmask":"24"
      }]', TRUE),
  );
}
